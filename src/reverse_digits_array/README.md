# 📌 문제 이름 (문제 번호)

## 📖 문제 정보

| 항목 | 내용 |
| --- | --- |
| **출처** | `[백준/프로그래머스 등]` |
| **링크** | `[문제 URL]` |
| **난이도** | `[Silver V / Lv. 1 등]` |
| **분류** | `[#구현, #DP, #DFS/BFS 등]` |

---

## 📝 문제 요약

- 문제를 한두 문장으로 간단히 요약합니다. (예: "N x M 맵에서 바이러스가 퍼지는 최소 시간을 BFS로 탐색하는 문제")

---

## 💡 핵심 아이디어

- 문제를 해결한 가장 중요한 전략이나 알고리즘을 간략하게 작성합니다.
- (예: "모든 치킨집 조합 중, 각 집에서 가장 가까운 치킨집 거리를 계산하여 도시의 치킨 거리가 최소가 되는 경우를 찾아야 한다. -> **백트래킹(조합) + 구현**")

---

## ✍️ 풀이 과정

1. **(데이터 입력/자료구조)**: 데이터를 어떤 자료구조에 저장했는지 (예: `ArrayList`, `int[][] map` 등)
2. **(탐색/로직 1)**: 어떤 순서로 탐색 또는 계산을 진행할지
3. **(예외 처리)**: 고려해야 했던 특별한 케이스 (예: "N이 1일 경우", "값이 0일 경우" 등)

---

## 🧐 시간 복잡도 분석

- O(N2)
- (이유: "2중 for문을 사용하여 맵 전체를 순회했기 때문입니다.")
- (또는: "Arrays.sort()를 사용하여 $O(N \log N)$이 소요되었습니다.")

---

## 🧠 오답 노트 / 배운 점

- **(실수 1)**: 처음에 `int`형을 사용했다가 범위를 초과하여 런타임 에러 발생 -> `long` 타입으로 변경하여 해결.
- **(배운 점)**: 이진 탐색은 **정렬된 배열**에서만 사용 가능하다는 것을 다시 한번 상기함. `Arrays.binarySearch()` 메서드 사용법을 익힘.
- **(느낀 점)**: 문제를 끝까지 읽지 않고 중간에 지레짐작하여 시간을 낭비함. 다음부터는 제한 사항과 입출력 예시를 꼼꼼히 보자.
